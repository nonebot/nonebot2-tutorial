# 事件响应器

事件响应器（`Matcher`）是对接收到的事件进行响应的基本单元，所有的事件响应器都继承自 `Matcher` 基类。

就像人或动物可以针对不同的外界输入做出不同的反应，例如看到了美食会流口水，被火烧到了会缩手。在 Nonebot2 中，事件响应器也可以通过一系列特定的规则精准的 **筛选** 出 **某一类型的事件**，并按照 **特定的流程** 交由 **指定的的事件处理依赖** 进行处理。

## 事件响应器的辅助函数

所有的事件响应器都继承自 `Matcher` 基类，而直接使用继承自 `Matcher`  基类的方法创建事件响应器过于繁琐。于是 NoneBot2 中提供了 “事件响应器的辅助函数”（下称辅助函数）来辅助用户用 **最简的方式** 创建 **带有不同规则预设** 的事件响应器，极大的提高了代码的可读性和书写效率。通常情况下，我们可以仅使用辅助函数便完成几乎全部事件响应器的创建，而不需要自行定义 `Matcher` 类。

在 NoneBot2 中，辅助函数以 `on()` 或 `on_matchertype()` 为形式出现（例如 `on_message()` ），被调用后根据自身的类型及传入的参数返回一个 `Type[Matcher]` 的新的事件响应器。

### 多种多样的辅助函数

目前，NoneBot2 共提供了12种功能各异的辅助函数、1种具有共同命令名称前缀的命令组和1种具有共同参数的响应器组，具体内容可参考[进阶 - 事件响应器及辅助函数](../../进阶/功能/事件响应器及辅助函数.md#事件响应器的辅助函数)。

## 创建事件响应器

我们可以使用 `nonebot.plugin` 模块中定义的辅助函数来创建事件响应器，此处我们采用 `on_command` 作为演示。

::: tips
用于定义事件响应器的辅助函数已经在 `nonebot` 主模块中被 `re-export`，所以直接从 `nonebot` 导入也是可以的。
:::

```py title=weather.py
from nonebot import on_command
# from nonebot.plugin import on_command

matcher = on_command('天气') # 注册事件响应器
```

这样，我们就获得一个名为 `matcher` 的事件响应器了，这个事件响应器会对 `[命令头]天气` 开头的命令进行响应。

<<<<<<< Updated upstream
>Tips
如果一条消息中包含 “对机器人的@” 或 “机器人的昵称”，例如`@awesome-bot /天气` 时，协议适配器会将 `event.is_tome()` 判断为 `True` ，同时 **部分协议适配器** 也会自动去除 `@awesome-bot`，即事件响应器收到的信息内容为 `/天气`。
也就是说，在 **部分事件响应器** 中，事件响应器所匹配的原始数据是不受 “对机器人的@” 或 “机器人的昵称” 影响的，这一影响会在其他匹配规则中体现出来。具体请参考对应的协议适配器文档。
=======
::: tips
如果一条消息中包含 “对机器人的@” 或 “机器人的昵称”，例如`@awesome-bot /天气` 时，协议适配器会将 `event.is_tome()` 判断为 `True` ，同时 **部分协议适配器** 也会自动去除 `@awesome-bot`，即事件响应器收到的信息内容为 `/天气`。
也就是说，在 **部分事件响应器** 中，事件响应器所匹配的原始数据是不受 “对机器人的@” 或 “机器人的昵称” 影响的，这一影响会在其他匹配规则中体现出来。具体请参考对应的协议适配器文档。
:::
>>>>>>> Stashed changes

### 为事件响应器添加参数

在事件响应器的辅助函数中，我们可以添加一些参数来对事件响应器进行更加精细的调整，例如事件响应器的优先级、匹配规则、权限限制等。例如:

```py
from nonebot import on_command

matcher = on_command('天气',aliases={'weather','tq'},priority=10,block=True)
```

这样我们就获得了一个 `可以响应天气、weather、tq三个命令` 、 `优先级为10` 、 `阻断事件传播` 的事件响应器。

::: tips
需要注意的是，不同的事件响应器有不同的可选参数，在使用之前可以参考[进阶 - 事件响应器及其辅助函数](../../进阶/功能/事件响应器及辅助函数.md#事件响应器的辅助函数)或编辑器的提示。
:::

# 权限控制

**权限控制**是机器人在实际应用中需要解决的重点问题之一，NoneBot2 提供了灵活的权限控制机制——`Permission`。

`Permission` 可以通过识别用户的类型对其进行分类，并生成对应的 `权限`，例如 `SUPERUSER`。在事件响应器及事件处理流程中，我们可以轻松的借助 `权限` 对用户进行区分，以对其做出不同的回应。

```python
from nonebot.permission import SUPERUSER
from nonebot import on_command


matcher = on_command("测试超管", permission=SUPERUSER)

@matcher.handle()
async def _():
    await matcher.send("超管命令测试成功")
```

如上方示例所示，在注册事件响应器时，我们设置了 `permission` 参数，那么这个事件处理器在触发事件前的检查阶段会对用户身份进行验证，如果不符合我们设置的条件（此处即为 `超级用户`）则会响应失败。

<!-- TODO: 这里补充超级用户的链接 -->

目前，NoneBot2 仅内置了一个 `SUPERUSER` 权限，同时也可由协议适配器或用户自行定义更多的权限，并对权限进行 `或运算`。同时，权限不仅可以在注册事件响应器时使用，也可以在事件处理流程中使用。此部分将在将会在 ***（进阶部分的对应内容）*** 中进行介绍。

<!-- TODO: 补充进阶内容的链接 -->

```python title=weather.py
from nonebot.adapters import Message, MessageSegment
from nonebot.params import CommandArg
from nonebot.plugin import on_command
from nonebot.permission import SUPERUSER

# 通过此处的函数来获取天气信息
async def get_weather(city: str):
    weather = 'balabala...' # 此处填写获取到的天气信息
    return weather


matcher = on_command('天气',permission=SUPERUSER) # 注册事件响应器

@matcher.handle() # 为事件响应器添加一个处理函数
async def handle_func(args: Message = CommandArg()):
    city = args.extract_plain_text() # 获取用户发送的命令信息
    if city in ['广州','上海']:
        weather_info = Message(f'今天 {city} 的天气是:') + MessageSegment.text(await get_weather(city=city)) # 拼接回复消息
        await matcher.finish(weather_info)
    else:
        await matcher.finish(f'您输入的城市 {city} 暂不支持查询，请重试...')
```

如上方示例所示，我们在weather插件中加入了权限控制，目前此插件仅会对bot的 `超级用户` 进行响应，并忽略掉其他用户的请求。
